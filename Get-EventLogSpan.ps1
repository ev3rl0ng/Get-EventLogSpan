Function Get-EventLogSpan {

#Requires -Version 2.0 
[CmdletBinding()] 


<#
	.SYNOPSIS
	Function for veryfing Windows events log span
  
	.PARAMETER ComputerName

  
	.PARAMETER LogsScope

  
	.ExcludeEmptyLogs


    .WarningLevel

    
    .CriticalLevel

    
    .OutputDirection

    
    .ColourOutput

     
	.EXAMPLE

      
	AUTHOR: Wojciech Sciesinski, wojciech[at]sciesinski[dot]net
		
	KEYWORDS: Windows, PowerShell, EventLogs
   
	BASEREPOSITORY: https://github.com/it-praktyk/Get-EventLogSpan

	VERSION HISTORY
	0.3 - 2015-01-20 - first version published on GitHub
    0.4 - 2015-01-21 - output updated - now include timespan, warning and critical levels added as parameters, output can be coloured

   #>
   
#>

param (
	[parameter(mandatory=$false,Position=0)]
	[String]$ComputerName="localhost",
	
	[parameter(mandatory=$false,Position=1)]
	[ValidateSet("All","Classic")]
	[String]$LogsScope="Classic",
	
	[parameter(mandatory=$false,Position=2)]
	[Bool]$ExcludeEmptyLogs=$true,

    [parameter(mandatory=$false,Position=3)]
    [Int32]$WarningLevelDays=30,

    [parameter(mandatory=$false,Position=4)]
    [Int32]$CriticalLevelDays=7,

    [parameter(mandatory=$false,Position=5)]
    [ValidateSet("Console","HTML")]
    [String]$OutputDirection="Console",

    [parameter(mandatory=$false,Position=6)]
    [Bool]$ColourOutput=$true

)

Begin {

	    $Results=@()

        $StartTime = Get-Date

        $WarningColor = "Yellow"
        
        $CriticalColor = "Red" 

}

Process {
	
	if ($LogsScope -eq "Classic") {

		$Logs = Get-WinEvent -ListLog * |  Where-Object { $_.IsClassicLog }
		
	}
	Else {
	
		$Logs = Get-WinEvent -ListLog *
	
	}
	
	$Logs | ForEach {
	
		$OldestEventEntryTime = Get-OldestEventTime -LogName $_.LogName.ToString()

        If ($OldestEventEntryTime) {

            $LogTimeSpan = New-TimeSpan -Start $OldestEventEntryTime -End $StartTime

            If ($LogTimeSpan -lt $(New-TimeSpan -Days $WarningLevelDays) -and $LogTimeSpan -gt $(New-TimeSpan -Days $CriticalLevelDays)) {

                $LogSpanStatus = "Warning"

            }
            elseif ( $LogTimeSpan -lt $(New-TimeSpan -Days $CriticalLevelDays)) {

                $LogSpanStatus = "Critical"

            }
            else {

                $LogSpanStatus = "Normal"

            }


        }

       
		
		$hash =  @{ 
			ComputerName     	= $ComputerName
			LogName				= $_.LogName
			OldestEventTime		= $OldestEventEntryTime
            LogTimeSpan = $LogTimeSpan
            LogSpanStatus = $LogSpanStatus

		} 
                
		$Result = New-Object PSObject -Property $hash 
				
		Write-Verbose $Result
		
		If (($Result.OldestEventTime -ne $null) -or  !$ExcludeEmptyLogs) {
				
			$Results+=$Result
		}
		
	}
	
}

End {

    If ($OutputDirection -eq "Console") {

        $Results | ForEach-Object -Process {

        
            if ($_.LogSpanStatus -eq "Critical" -and $ColourOutput) {
            
               Write-ColorOutput -ForeGroundColor $CriticalColor -OutputData $_
               
            }
            elseif ($_.LogSpanStatus -eq "Warning" -and $ColourOutput) {

                Write-ColorOutput -ForeGroundColor $WarningColor -OutputData $_
                
            }
            else {

                Write-Output -InputObject $_
                
            }
        }

    }

}

}

Function Get-OldestEventTime {

[CmdletBinding()] 

param (

	[parameter(mandatory=$false,Position=0)]
	[String]$ComputerName="localhost",

	[parameter(mandatory=$false,Position=1,ValueFromPipeline=$false)]
	[String]$LogName

)

begin {

	#Code was partially generated by Log Parser Studio tool
	
	$LogQuery = New-Object -ComObject "MSUtil.LogQuery"
	
	$InputFormat = New-Object -ComObject "MSUtil.LogQuery.EventLogInputFormat"

	$OutputFormat = New-Object -ComObject "MSUtil.LogQuery.NativeOutputFormat"
	
	$InputFormat.fullText=1
	$InputFormat.resolveSIDs=0
	$InputFormat.formatMsg=1
	$InputFormat.msgErrorMode="MSG"
	$InputFormat.fullEventCode=0
	$InputFormat.direction="FW"
	$InputFormat.stringsSep="|"
	$InputFormat.binaryFormat="PRINT"
	$InputFormat.ignoreMessageErrors=1
	

	#Write-Verbose "Executing query for $LogName on $ComputerName"

	$SQLQuery = "SELECT TOP 1 TimeGenerated FROM '{1}' ORDER BY TimeGenerated ASC" -f $ComputerName,$LogName
	
	$rtnVal = $LogQuery.Execute($SQLQuery, $InputFormat)
	
}

process {
	
	try{
		do{
			$lp_return = @{}
	
			$log_entry = $rtnVal.getrecord()

			$lp_return.add("TimeGenerated",[datetime]$log_entry.getvalue("TimeGenerated"))

			$rtnVal.movenext()
	

		} while ($rtnVal.atend() -eq $false)
	
	}

	catch {
	
		$lp_return.add("TimeGenerated",$null)
		
		Write-Verbose "The log $LogName on $ComputerName is unavailable or empty."

	}
	
	Finally {
	
			$Result = New-Object PSObject -Property $lp_return
	
	}
	
}

end {

	$Result = New-Object PSObject -Property $lp_return

	Return $Result.TimeGenerated

}

}


function Write-ColorOutput {

param (


	[parameter(mandatory=$true,Position=0)]
	[String]$ForeGroundColor,

    [parameter(mandatory=$true,Position=1)]
    $OutputData

)

    #Source
    #http://stackoverflow.com/questions/4647756/is-there-a-way-to-specify-a-font-color-when-using-write-output

    #Modified by Wojciech Sciesinski

    # save the current color
    $fc = $host.UI.RawUI.ForegroundColor

    # set the new color
    $host.UI.RawUI.ForegroundColor = $ForegroundColor

    # Write output
    Write-Output $OutputData

    # restore the original color
    $host.UI.RawUI.ForegroundColor = $fc

}
